1、调整线程的优先级
  Java线程的优先级用整数标识，取值范围是1-10，Thread类有以下三个静态常量：
    static int MAX_PRIORITY  线程可以具有的最高优先级，取值为10
    static int MIN_PRIORITY  线程可以具有的最低优先级，取值为1
    static int NORM_PRIORITY  分配给线程的默认优先级，取值为5
  Thread类setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
  线程的优先级具有继承关系，比如A线程汇总创建了B线程，那么B和A具有相同的优先级。
  JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，
  应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
2、线程睡眠：sleep(long millis)方法，使线程转到阻塞状态，millis参数设置睡眠的时间，以毫秒为单位。
   当睡眠结束时，就转为就绪（Runnable）状态，sleep()平台移植性号。
3、线程等待：wait()方法导致当前线程等待，直到其他线程调用此对象的notify()或notifyAll()方法。
4、线程让步：yield()方法暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
   yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。
   因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。
   但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
5、线程加入：join()方法等待其他线程终止，在当前线程中调用另一个线程的join()方法，则会使当前线程转入阻塞状态
   知道另一个线程运行结束，当前线程由阻塞转为就绪状态。
6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。
   如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。
   线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。
   被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
   例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。
   类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
   注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。
7、线程中断：interrupt()方法中断某个线程，这种结束方式比较粗暴，
   如果t线程打开了某个资源还没来得及关闭，也就是run方法还没有执行完就强制结束线程，会导致资源无法关闭
   
8、sleep()和yield()的区别：
     sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；
     yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。
     sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，
     yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。
      实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，
      否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
     另外，sleep 方法允许较低优先级的线程获得运行机会，
     但yield()方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。
     在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 
9、wait()和sleep()区别：
    共同点：
      1）他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回
      2）wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻跑出interruptedException。
         如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。
         如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，
         在catch() {} 中直接return即可安全地结束线程。
         需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。
         对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。
         但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。
    不同点：
      1）Thread类的方法：sleep()和yield()等
         Object类的方法：wait()和notify()等
      2）每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 
         sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 
      3）wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
      4）sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
      综上，sleep()和wait()方法的最大区别是：
　　　　sleep()睡眠时，保持对象锁，仍然占有该锁；
　　　　而wait()睡眠时，释放对象锁。
　    wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。
    
